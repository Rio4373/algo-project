# Проект:  "Разработка стратегии в стиле боя в игре "Герои Меча и Магии 3" против искусственного интеллекта".
Проект включает в себя реализацию 4-х методов игры с заданной сложностью алгоритмов или выше.
## Методы
### 1 Метод generate интерфейса GeneratePreset
#### Требования
- Метод формирует армию с учетом максимальной эффективности юнитов по соотношению атаки к стоимости и здоровья к стоимости.
- Метод должен соблюдать ограничение в 11 юнитов каждого типа и общее ограничение по очкам.
- Алгоритмическая сложность должна быть O(n * m) или лучше, где:n — количество типов юнитов, m — максимальное количество юнитов в армии.
#### Алгоритмическая сложность
1) Внешний цикл перебирает каждый юнит в списке unitList, что делает его сложностью O(n), где n — количество типов юнитов.
2) Внутренний цикл выполняется для каждого типа юнита, ограничивая его количеством не более 11 (или максимальным количеством очков, доступных для данного типа), что приводит к сложности O(m), где m — максимальное количество юнитов.
3) Общая сложность метода получается O(n×m),
где n — количество типов юнитов, m — максимальное количество юнитов в армии.
### 2 Метод simulate интерфейса SimulateBattle
#### Требования
- Сортировка юнитов по атакующему значению: На каждом раунде юниты сортируются по убыванию их атакующих характеристик. Это должно быть выполнено правильно.
- Симуляция боя: Юниты атакуют по очереди, и они исключаются из очереди при смерти. Если одна из армий потеряет всех своих юнитов, она продолжает пропускать ходы, пока противник не завершит свои атаки.
- Логирование атак: После каждой атаки выводится лог с помощью метода printBattleLog.printBattleLog(unit, target).
- Алгоритмическая сложность: Требуется, чтобы сложность была не хуже O(n² * log n), где n — количество юнитов в каждой армии.
#### Алгоритмическая сложность
1) Сортировка юнитов по атакующему значению: Метод sortUnitsByAttack использует стандартную сортировку, которая имеет сложность O(n * log n), где n — количество юнитов в армии. Сортировка выполняется на каждом раунде, и так как мы проводим симуляцию, количество раундов будет зависеть от количества юнитов.
2) Процесс симуляции:
Каждый раунд включает в себя два этапа атак (по очереди для каждой армии), что дает сложность O(n) для каждого этапа.
Внутри метода performAttacks осуществляется обход и возможно удаление элементов из списка (что также требует O(n) времени для каждого этапа).
Таким образом, на каждом раунде сложность сортировки юнитов O(n * log n), а количество раундов зависит от количества живых юнитов (может быть до O(n), если не исключать мертвых юнитов до конца игры). Следовательно, сложность каждого раунда — O(n * log n) + O(n) = O(n * log n).
3) Общая сложность:
В худшем случае мы имеем O(n) раундов (если армии не теряют юнитов слишком быстро), и на каждом раунде выполняется сортировка и атаки с сложностью O(n * log n).
Общая сложность симуляции получается O(n² * log n).
### 3 Метод getSuitableUnits интерфейса SuitableForAttackUnitsFinder
#### Требования
- Определение подходящих юнитов для атаки:
Для атакующей армии компьютера (левая армия) подходящий юнит — это юнит армии игрока, который не закрыт справа другим юнитом.
Для атакующей армии игрока (правая армия) подходящий юнит — это юнит армии компьютера, который не закрыт слева другим юнитом.
- Возвращаемое значение:
Метод должен возвращать список юнитов, которые могут быть атакованы согласно вышеописанным правилам.
Алгоритмическая сложность:
- Сложность должна быть O(n * m), где n — количество юнитов в ряду, а m — количество рядов (которые в данной задаче фиксированы на 3). Соответственно, сложность будет O(n), где n — количество юнитов в одном ряду.
#### Алгоритмическая сложность
1) Обход всех юнитов:
Метод проходит по всем юнитам каждого ряда. Для каждого юнита выполняется проверка на живость и затем проверка на закрытие (в зависимости от того, атакует ли армия игрока или компьютера).
В худшем случае мы проходим по всем юнитам в каждом ряду, то есть за один проход по ряду сложность составляет O(n), где n — количество юнитов в ряду.
Поскольку количество рядов фиксировано и равно 3, общее количество операций — O(n * 3) = O(n).
Проверка на правый и левый юнит: Для каждого юнита мы выполняем дополнительную проверку, которая имеет сложность O(n) (в худшем случае, когда все юниты находятся в одном ряду и мы проверяем все элементы справа или слева). Таким образом, каждый юнит обрабатывается за O(n) времени.
2) Общая сложность:
Мы проходим по всем рядам и юнитам, выполняя операции за O(n) для каждого ряда, и, поскольку количество рядов фиксировано, сложность метода составляет O(n * m), где m — количество рядов (в данном случае 3) и n — количество юнитов в ряду.
Поскольку количество рядов фиксировано, то сложность будет равна O(n).
### 4 Метод getTargetPath интерфейса UnitTargetPathFinder
#### Требования
- Нахождение кратчайшего пути между атакующим и атакуемым юнитом.
Метод должен возвращать список координат (в виде объектов Edge), который будет представлять кратчайший путь от атакующего юнита до атакуемого, включая оба юнита.
Если путь не существует (например, если все возможные пути заблокированы), метод должен вернуть пустой список.
- Алгоритмическая сложность:
Ожидаемая сложность: O((WIDTH * HEIGHT) * log(WIDTH * HEIGHT)), где WIDTH = 27 и HEIGHT = 21 — это размеры игрового поля.
#### Алгоритмическая сложность
1) Основная сложность алгоритма:
Алгоритм Дейкстры с использованием приоритетной очереди имеет сложность O((V + E) * log(V)), где V — количество вершин (клеток), а E — количество ребер (соседей).
В данном случае V — это количество клеток на поле (WIDTH * HEIGHT), а E — количество соседей для каждой клетки (в среднем 4).
Сложность алгоритма будет равна O((WIDTH * HEIGHT) * log(WIDTH * HEIGHT))
